/* TEST FILES SINCE THIS PROGRAM SUUUUUUUUCKS


CRAPPY AVLTREE IMPLEMENTATION
****************************
#include <iostream>

using namespace std;

template <typename Comparable>
class AVLTree { 
    private:
        struct HB_Node
        {
            Comparable element;
            HB_Node *left;
            HB_Node *right;
            int height;
            int lsize;
            int rsize;
            
            HB_Node( const Comparable & theElement, HB_Node *lt, HB_Node *rt,
                int h = 0, int ls = 0, int rs = 0 ) : element( theElement ), left( lt ), right( rt ),
                    height ( h ), lsize( ls ), rsize( rs ) { }
        };
        HB_Node *root;
        
    public:
        unsigned char height(node* p);

};

unsigned char height(node* p)
{
    return p?p->height:0;
}

int bfactor(node* p)
{
    return height(p->right)-height(p->left);
}

void fixheight(node* p)
{
    unsigned char hl = height(p->left);
    unsigned char hr = height(p->right);
    p->height = (hl>hr?hl:hr)+1;
}

node* rotateright(node* p)
{
    node* q = p->left;
    p->left = q->right;
    q->right = p;
    fixheight(p);
    fixheight(q);
    return q;
}

node* rotateleft(node* q)
{
    node* p = q->right;
    q->right = p->left;
    p->left = q;
    fixheight(q);
    fixheight(p);
    return p;
}

node* balance(node* p) // balancing the p node
{
    fixheight(p);
    if( bfactor(p)==2 )
    {
        if( bfactor(p->right) < 0 )
            p->right = rotateright(p->right);
        return rotateleft(p);
    }
    if( bfactor(p)==-2 )
    {
        if( bfactor(p->left) > 0  )
            p->left = rotateleft(p->left);
        return rotateright(p);
    }
    return p; // balancing is not required
}

node* insert(node* p, int k) // insert k key in a tree with p root
{
    if( !p ) return new node(k);
    if( k<p->key )
        p->left = insert(p->left,k);
    else
        p->right = insert(p->right,k);
    return balance(p);
}

node* findmin(node* p) // find a node with minimal key in a p tree 
{
    return p->left?findmin(p->left):p;
}

node* removemin(node* p) // deleting a node with minimal key from a p tree
{
    if( p->left==0 )
        return p->right;
    p->left = removemin(p->left);
    return balance(p);
}

node* remove(node* p, int k) // deleting k key from p tree
{
    if( !p ) return 0;
    if( k < p->key )
        p->left = remove(p->left,k);
    else if( k > p->key )
        p->right = remove(p->right,k);  
    else //  k == p->key 
    {
        node* q = p->left;
        node* r = p->right;
        delete p;
        if( !r ) return q;
        node* min = findmin®;
        min->right = removemin®;
        min->left = q;
        return balance(min);
    }
    return balance(p);
}

*************************************
LESS CRAPPY AVLTREE IMPLEMENTATION 

#include <algorithm>
#include <iostream>
//Compile code is g++ AVLTree.cpp -std=gnu++0x
using namespace std;

template <typename Comparable>
class AVLTree { 
    private:
        struct HB_Node {
            Comparable element;
            HB_Node *left;
            HB_Node *right;
            int height;
            int lsize;
            int rsize;
            
            HB_Node( const Comparable & theElement, HB_Node *lt, HB_Node *rt,
                int h = 0, int ls = 0, int rs = 0 ) : element( theElement ), left( lt ), right( rt ),
                height ( h ), lsize( ls ), rsize( rs ) { }
        };
        HB_Node *root;
        
    public:
        AVLTree() : root(nullptr) { }

        int GetHeight(HB_Node* root);
        int Diff(HB_Node* root);
        HB_Node* RightRight_Rotation(HB_Node* root);
        HB_Node* LeftLeft_Rotation(HB_Node* root);
        HB_Node* LeftRight_Rotation(HB_Node* root);
        HB_Node* RightLeft_Rotation(HB_Node* root);
        HB_Node* Balance(HB_Node* root);
        HB_Node* Insert(HB_Node* root, int value);
        
        void Display(HB_Node* root, int level);
};

template <typename Comparable>
int AVLTree<Comparable>::GetHeight(HB_Node *temp) {
    height = 0;
    if (temp) {
        int l_GetHeight = GetHeight(temp->left);
        int r_GetHeight = GetHeight(temp->right);
        int max_GetHeight =  max(l_GetHeight, r_GetHeight);
        height = max_GetHeight + 1;
    }

    return height;
}

template <typename Comparable>
int AVLTree<Comparable>::Diff(HB_Node* temp) {
    int l_GetHeight = GetHeight(temp->left);
    int r_GetHeight = GetHeight(temp->right);
    int b_factor = (l_GetHeight - r_GetHeight);
    return b_factor;
}


template <typename Comparable>
HB_Node* AVLTree<Comparable>::RightRight_Rotation(HB_Node* parent) {
    HB_Node* temp;
    temp = parent->right;
    parent->right = temp->left;
    temp->left = parent;
    return temp;
}

template <typename Comparable>
HB_Node* AVLTree<Comparable>::LeftLeft_Rotation(HB_Node* parent) {
    HB_Node* temp;
    temp = parent->left;
    parent->left = temp->right;
    temp->right = parent;
    return temp;
}

template <typename Comparable>
HB_Node* AVLTree<Comparable>::LeftRight_Rotation(HB_Node* parent) {
    Node* temp = parent->left;
    parent->left = RightRight_Rotation(temp);
    return LeftLeft_Rotation(parent);
}

template <typename Comparable>
HB_Node* AVLTree<Comparable>::RightLeft_Rotation(HB_Node* parent) {
    Node* temp = parent->right;
    parent->right = LeftLeft_Rotation(temp);
    return RightRight_Rotation(parent);
}

template <typename Comparable>
HB_Node* AVLTree<Comparable>::Balance(HB_Node* temp) {
    int balanceFactor = Diff(temp);
  
    if (balanceFactor > 1) {
        if (Diff (temp->left) > 0) {
            temp = LeftLeft_Rotation(temp);
        } 
        else {
            temp = LeftRight_Rotation(temp);
        }
    } 
    else if (balanceFactor < -1) {
        if (Diff(temp->right) > 0) {
          temp = RightLeft_Rotation(temp);        
        } 
        else {
            temp = RightRight_Rotation(temp);
        }
    }

    return temp;
}

template <typename Comparable>
HB_Node* AVLTree<Comparable>::Insert(HB_Node* root, int value) {
    if (!root) {
        root = new HB_Node;
        root->data = value;
        root->left = NULL;
        root->right = NULL;
        return root;
    } 
    else if (value < root->data) {
        root->left = Insert(root->left, value);
        root = Balance(root);
    } 
    else if (value >= root->data) {
        root->right = Insert(root->right, value);
        root = Balance(root);
    }

    return root;
}

template <typename Comparable>
void AVLTree<Comparable>::Display(HB_Node* current, int level) {
  if (!current) return;

  Display(current->right, level + 1);
  std::cout << std::endl;
  if (current == root()) {
    std::cout<<"Root -> ";
    for (int i = 0; i < level && current != root(); ++i) {
      cout << "           ";
    }
    cout << current->data;
    Display(current->left, level+1);
  }
}

/**
 *  * Prompts user for input selection using stdin.
 *   
 int main() {
  int choice = 0, item = 0;
  AVLTree<int> avl;

  while(1) {
     cout << "Enter your choice: " <<  endl;
     cout << "1: Insert a value" <<  endl;
     cout << "2: Display balanced AVL Tree" <<  endl;
     cout << "3: Print Inorder traversal" <<  endl;
     cout << "4: Print Preorder traversal" <<  endl;
     cout << "5: Print Postorder traversal" <<  endl;
     cout << "6: Exit" <<  endl;
     cin >> choice;
    switch(choice) {
      case 1:
       cout << "Enter value to be Inserted: ";
       cin >> item;
      avl.Insert(avl.root(), item);
      break;
      case 2:
      if (!avl.root()) {
         cout << "Tree is empty!" <<  endl;
        continue;
      }
       cout << "Balanced AVL Tree:" << endl;
      avl.Display(avl.root(), 1);
      break;
      
      case 6: 
      exit(1);
      break;
      
      default:
       cout << "Wrong choice" <<  endl;
    }
  }

  return 0;
}

//Taken from: https://github.com/piperchester/avl-tree

*/

/*
********************************************************
UBTREE IMPLEMENTATION

template <typename Comparable>
class UBTree { 
    private:
        struct HB_Node
        {
            Comparable element;
            HB_Node *left;
            HB_Node *right;
            int height;
            int lsize;
            int rsize;
            
            HB_Node( const Comparable & theElement, HB_Node *lt, HB_Node *rt,
                int h = 0, int ls = 0, int rs = 0 ) : element( theElement ), left( lt ), right( rt ),
                    height ( h ), lsize( ls ), rsize( rs ) { }
        };
        HB_Node *root;
        
    public:  
        void insert(int);
        void del(int);
        void case_a( HB_Node *, HB_Node *);
        void case_b( HB_Node *, HB_Node *);
        void case_c( HB_Node *, HB_Node *);
        UBTree()
        {
            root = NULL;
        }
};

template <typename Comparable>
void UBTree::insert( HB_Node *tree,  HB_Node *newnode)
{
    if (root == NULL)
    {
        root = new HB_Node;
        root->info = newnode->info;
        root->left = NULL;
        root->right = NULL;
        cout<<"Root Node is Added"<<endl;
        return;
    }
    if (tree->info == newnode->info)
    {
        cout<<"Element already in the tree"<<endl;
        return;
    }
    if (tree->info > newnode->info)
    {
        if (tree->left != NULL)
        {
            insert(tree->left, newnode);	
	}
	else
	{
            tree->left = newnode;
            (tree->left)->left = NULL;
            (tree->left)->right = NULL;
            cout<<"Node Added To Left"<<endl;
            return;
        }
    }
    else
    {
        if (tree->right != NULL)
        {
            insert(tree->right, newnode);
        }
        else
        {
            tree->right = newnode;
            (tree->right)->left = NULL;
            (tree->right)->right = NULL;
            cout<<"Node Added To Right"<<endl;
            return;
        }	
    }
}

template <typename Comparable>
void UBTree<Comparable>::del(int item)
{
     HB_Node *parent, *location;
    if (root == NULL)
    {
        cout<<"Tree empty"<<endl;
        return;
    }
    find(item, &parent, &location);
    if (location == NULL)
    {
        cout<<"Item not present in tree"<<endl;
        return;
    }
    if (location->left == NULL && location->right == NULL)
        case_a(parent, location);
    if (location->left != NULL && location->right == NULL)
        case_b(parent, location);
    if (location->left == NULL && location->right != NULL)
        case_b(parent, location);
    if (location->left != NULL && location->right != NULL)
        case_c(parent, location);
    free(location);
}

template <typename Comparable>
void UBTree<Comparable>::case_a(node *par, node *loc )
{
    if (par == NULL)
    {
        root = NULL;
    }
    else
    {
        if (loc == par->left)
            par->left = NULL;
        else
            par->right = NULL;
    }
}

//Binary search tree code found on http://www.sanfoundry.com/cpp-program-implement-binary-tree-2/

//Below is my shitty attempt at a prettyPrint implementation
        // if(t->right == nullptr) {
        //     cout << linePrefix << nodeTag << t->element << endl;
        //     if(t->left != nullptr) {
        //         nodeTag = " \\";
        //         linePrefix += "| ";
        //         cout << linePrefix << nodeTag << t->element << endl;
        //         return;
        //     }
        //     return;
        // }
        
        // else if(t->right != nullptr && t->left != nullptr) {
        //     linePrefix = "  ";
        //     nodeTag = " /";
        //     prettyPrint(t-> right, linePrefix, nodeTag);
        //     linePrefix = linePrefix.substr(0, linePrefix.size() - 2);
        //     cout << linePrefix << nodeTag << t->element << endl;
        //     prettyPrint(t->left, linePrefix, nodeTag);
        // }
